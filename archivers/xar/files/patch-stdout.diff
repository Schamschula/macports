--- src/xar.c.orig	2022-03-09 07:52:07.000000000 -0600
+++ src/xar.c	2022-03-09 19:29:08.000000000 -0600
@@ -53,8 +53,15 @@
 #include "config.h"
 #include "../lib/filetree.h"
 #include "util.h"
+
+#define MIN_XAR_NEW_OPTIONS 0x01060180
+
 #define SYMBOLIC 1
 #define NUMERIC  2
+
+static unsigned long xar_lib_version = 0;
+static int xar_lib_version_fetched = 0;
+
 static int Perms = 0;
 static int Local = 0;
 static char *Subdoc = NULL;
@@ -73,6 +80,7 @@
 static int LinkSame = 0;
 static int NoOverwrite = 0;
 static int SaveSuid = 0;
+static int ToStdout = 0;
 
 struct lnode {
 	char *str;
@@ -457,24 +465,27 @@
 		
 		if( matched ) {
 			struct stat sb;
-			if( NoOverwrite && (lstat(path, &sb) == 0) ) {
+			if( !ToStdout && NoOverwrite && (lstat(path, &sb) == 0) ) {
 				printf("%s already exists, not overwriting\n", path);
 			} else {
 				const char *prop = NULL;
 				int deferred = 0;
 				if( xar_prop_get(f, "type", &prop) == 0 && prop != NULL ) {
 					if( strcmp(prop, "directory") == 0 ) {
+						if (!ToStdout) {
 						struct lnode *tmpl = calloc(sizeof(struct lnode),1);
-						tmpl->str = (char *)f;
-						tmpl->next = dirs;
-						dirs = tmpl;
-						deferred = 1;
+							tmpl->str = (char *)f;
+							tmpl->next = dirs;
+							dirs = tmpl;
+							deferred = 1;
+						}
 					}
 				}
 				if( ! deferred ) {
-					files_extracted++;
-					print_file(x, f);
-					xar_extract(x, f);
+					if (xar_extract(x, f) == 0)
+						files_extracted++;
+					else if (!ToStdout)
+						fprintf(stderr, "Unable to extract file %s\n", path);
 				}
 			}
 		}
@@ -859,6 +870,8 @@
 	fprintf(stderr, "\t                      to a document in cwd named <name>.xml\n");
 	fprintf(stderr, "\t--exclude        POSIX regular expression of files to \n");
 	fprintf(stderr, "\t                      ignore while archiving.\n");
+	fprintf(stderr, "\t--to-stdout      Write file contents to standard out when extracting\n");
+	fprintf(stderr, "\t-O               Synonym for \"--to-stdout\"\n");
 	fprintf(stderr, "\t--rsize          Specifies the size of the buffer used\n");
 	fprintf(stderr, "\t                      for read IO operations in bytes.\n");
 	fprintf(stderr, "\t--coalesce-heap  When archived files are identical, only store one copy\n");
@@ -917,6 +953,7 @@
 		{"keep-existing",    no_argument,       0, 15},
 		{"keep-setuid",      no_argument,       0, 16},
 		{"compression-args", required_argument, 0, 17},
+		{"to-stdout",        no_argument, 		0, 'O'},
 		{ 0, 0, 0, 0}
 	};
 
@@ -925,7 +962,7 @@
 		exit(1);
 	}
 
-	while( (c = getopt_long(argc, argv, "axcC:vtjzf:hpPln:s:d:vk", o, &loptind)) != -1 ) {
+	while( (c = getopt_long(argc, argv, "axcOC:vtjzf:hpPln:s:d:vk", o, &loptind)) != -1 ) {
 		switch(c) {
 		case  1 : // toc-cksum
 			if( !optarg ) {
@@ -1150,6 +1187,13 @@
 		case 'l': // stay on local device
 			Local = 1;
 			break;
+		case 'O':
+ 			if (xar_lib_version < MIN_XAR_NEW_OPTIONS) {
+ 				fprintf(stderr, "--to-stdout requires a newer xar library\n");
+ 				exit(1);
+ 			}
+ 			ToStdout = 1;
+ 			break;
 		case 'n': // provide subdocument name
 			SubdocName = optarg;
 			break;
--- src/xar.1.orig	2020-05-12 22:28:17.000000000 -0500
+++ src/xar.1	2022-03-09 19:52:00.000000000 -0600
@@ -103,6 +103,13 @@
 the archive during creation or from being extracted during extraction.  
 This option can be specified multiple times.
 .TP
+\-\-to\-stdout
+Instead of creating files during extraction, write the file contents to standard output.
+Only the file data will be written to standard output.  All extended attributes, resource forks and other file properties are ignored with this option.
+.TP
+\-O
+Synonym for \-\-to\-stdout
+.TP
 \-\-rsize
 Specifies a size (in bytes) for the internal libxar read buffer while performing I/O.
 .TP
